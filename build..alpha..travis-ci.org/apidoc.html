<div class="apidocDiv">
<style>
/*csslint
*/
.apidocDiv {
    background: #fff;
    font-family: Arial, Helvetica, sans-serif;
}
.apidocDiv a[href] {
    color: #33f;
    font-weight: bold;
    text-decoration: none;
}
.apidocDiv a[href]:hover {
    text-decoration: underline;
}
.apidocCodeCommentSpan {
    background: #bbf;
    color: #000;
    display: block;
}
.apidocCodeKeywordSpan {
    color: #d00;
    font-weight: bold;
}
.apidocCodePre {
    background: #eef;
    border: 1px solid;
    color: #777;
    padding: 5px;
    white-space: pre-wrap;
}
.apidocFooterDiv {
    margin-top: 20px;
    text-align: center;
}
.apidocModuleLi {
    margin-top: 10px;
}
.apidocSectionDiv {
    border-top: 1px solid;
    margin-top: 20px;
}
.apidocSignatureSpan {
    color: #777;
    font-weight: bold;
}
</style>
<h1>api documentation for
    <a

        href="https://github.com/mourner/rbush"

    >rbush (v2.0.1)</a>
</h1>
<h4>High-performance 2D spatial index for rectangles (based on R*-tree with bulk loading and bulk insertion algorithms)</h4>
<div class="apidocSectionDiv"><a
    href="#apidoc.tableOfContents"
    id="apidoc.tableOfContents"
><h1>table of contents</h1></a><ol>

    <li class="apidocModuleLi"><a href="#apidoc.module.rbush">module rbush</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush">
            function <span class="apidocSignatureSpan"></span>rbush
            <span class="apidocSignatureSpan">(maxEntries, format)</span>
            </a>

        </li>

        <li>

            <span class="apidocSignatureSpan">object <span class="apidocSignatureSpan">rbush.</span>rbush.prototype</span>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rbush.rbush">module rbush.rbush</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.rbush">
            function <span class="apidocSignatureSpan">rbush.</span>rbush
            <span class="apidocSignatureSpan">(maxEntries, format)</span>
            </a>

        </li>

    </ol></li>

    <li class="apidocModuleLi"><a href="#apidoc.module.rbush.rbush.prototype">module rbush.rbush.prototype</a><ol>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype._adjustParentBBoxes">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_adjustParentBBoxes
            <span class="apidocSignatureSpan">(bbox, path, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype._all">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_all
            <span class="apidocSignatureSpan">(node, result)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype._allDistMargin">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_allDistMargin
            <span class="apidocSignatureSpan">(node, m, M, compare)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype._build">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_build
            <span class="apidocSignatureSpan">(items, left, right, height)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype._chooseSplitAxis">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_chooseSplitAxis
            <span class="apidocSignatureSpan">(node, m, M)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype._chooseSplitIndex">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_chooseSplitIndex
            <span class="apidocSignatureSpan">(node, m, M)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype._chooseSubtree">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_chooseSubtree
            <span class="apidocSignatureSpan">(bbox, node, level, path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype._condense">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_condense
            <span class="apidocSignatureSpan">(path)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype._initFormat">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_initFormat
            <span class="apidocSignatureSpan">(format)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype._insert">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_insert
            <span class="apidocSignatureSpan">(item, level, isNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype._split">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_split
            <span class="apidocSignatureSpan">(insertPath, level)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype._splitRoot">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_splitRoot
            <span class="apidocSignatureSpan">(node, newNode)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype.all">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>all
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype.clear">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>clear
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype.collides">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>collides
            <span class="apidocSignatureSpan">(bbox)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype.compareMinX">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>compareMinX
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype.compareMinY">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>compareMinY
            <span class="apidocSignatureSpan">(a, b)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype.fromJSON">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>fromJSON
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype.insert">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>insert
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype.load">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>load
            <span class="apidocSignatureSpan">(data)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype.remove">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>remove
            <span class="apidocSignatureSpan">(item, equalsFn)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype.search">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>search
            <span class="apidocSignatureSpan">(bbox)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype.toBBox">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>toBBox
            <span class="apidocSignatureSpan">(item)</span>
            </a>

        </li>

        <li>

            <a class="apidocElementLiA" href="#apidoc.element.rbush.rbush.prototype.toJSON">
            function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>toJSON
            <span class="apidocSignatureSpan">()</span>
            </a>

        </li>

    </ol></li>

</ol></div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rbush" id="apidoc.module.rbush">module rbush</a></h1>


    <h2>
        <a href="#apidoc.element.rbush.rbush" id="apidoc.element.rbush.rbush">
        function <span class="apidocSignatureSpan"></span>rbush
        <span class="apidocSignatureSpan">(maxEntries, format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>




</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rbush.rbush" id="apidoc.module.rbush.rbush">module rbush.rbush</a></h1>


    <h2>
        <a href="#apidoc.element.rbush.rbush.rbush" id="apidoc.element.rbush.rbush.rbush">
        function <span class="apidocSignatureSpan">rbush.</span>rbush
        <span class="apidocSignatureSpan">(maxEntries, format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function rbush(maxEntries, format) {
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this._initFormat(format);
    }

    this.clear();
}</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>


</div>

<div class="apidocSectionDiv">
<h1><a href="#apidoc.module.rbush.rbush.prototype" id="apidoc.module.rbush.rbush.prototype">module rbush.rbush.prototype</a></h1>


    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype._adjustParentBBoxes" id="apidoc.element.rbush.rbush.prototype._adjustParentBBoxes">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_adjustParentBBoxes
        <span class="apidocSignatureSpan">(bbox, path, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_adjustParentBBoxes = function (bbox, path, level) {
    // adjust bboxes along the given tree path
    for (var i = level; i &#x3e;= 0; i--) {
        extend(path[i], bbox);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (insertPath[level].children.length &#x3e; this._maxEntries) {
        this._split(insertPath, level);
        level--;
    } else break;
}

// adjust bboxes along the insertion path
this.<span class="apidocCodeKeywordSpan">_adjustParentBBoxes</span>(bbox, insertPath, level);
    },

    // split overflowed node into two
    _split: function (insertPath, level) {

var node = insertPath[level],
    M = node.children.length,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype._all" id="apidoc.element.rbush.rbush.prototype._all">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_all
        <span class="apidocSignatureSpan">(node, result)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_all = function (node, result) {
    var nodesToSearch = [];
    while (node) {
        if (node.leaf) result.push.apply(result, node.children);
        else nodesToSearch.push.apply(nodesToSearch, node.children);

        node = nodesToSearch.pop();
    }
    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

    this.clear();
}

rbush.prototype = {

    all: function () {
return this.<span class="apidocCodeKeywordSpan">_all</span>(this.data, []);
    },

    search: function (bbox) {

var node = this.data,
    result = [],
    toBBox = this.toBBox;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype._allDistMargin" id="apidoc.element.rbush.rbush.prototype._allDistMargin">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_allDistMargin
        <span class="apidocSignatureSpan">(node, m, M, compare)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_allDistMargin = function (node, m, M, compare) {

    node.children.sort(compare);

    var toBBox = this.toBBox,
        leftBBox = distBBox(node, 0, m, toBBox),
        rightBBox = distBBox(node, M - m, M, toBBox),
        margin = bboxMargin(leftBBox) + bboxMargin(rightBBox),
        i, child;

    for (i = m; i &#x3c; M - m; i++) {
        child = node.children[i];
        extend(leftBBox, node.leaf ? toBBox(child) : child);
        margin += bboxMargin(leftBBox);
    }

    for (i = M - m - 1; i &#x3e;= m; i--) {
        child = node.children[i];
        extend(rightBBox, node.leaf ? toBBox(child) : child);
        margin += bboxMargin(rightBBox);
    }

    return margin;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
},

// sorts node children by the best axis for split
_chooseSplitAxis: function (node, m, M) {

    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
        compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
        xMargin = this.<span class="apidocCodeKeywordSpan">_allDistMargin</span>(node, m, M, compareMinX),
        yMargin = this._allDistMargin(node, m, M, compareMinY);

    // if total distributions margin value is minimal for x, sort by minX,
    // otherwise it&#x27;s already sorted by minY
    if (xMargin &#x3c; yMargin) node.children.sort(compareMinX);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype._build" id="apidoc.element.rbush.rbush.prototype._build">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_build
        <span class="apidocSignatureSpan">(items, left, right, height)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_build = function (items, left, right, height) {

    var N = right - left + 1,
        M = this._maxEntries,
        node;

    if (N &#x3c;= M) {
        // reached leaf level; return leaf
        node = createNode(items.slice(left, right + 1));
        calcBBox(node, this.toBBox);
        return node;
    }

    if (!height) {
        // target height of the bulk-loaded tree
        height = Math.ceil(Math.log(N) / Math.log(M));

        // target number of root entries to maximize storage utilization
        M = Math.ceil(N / Math.pow(M, height - 1));
    }

    node = createNode([]);
    node.leaf = false;
    node.height = height;

    // split the items into M mostly square tiles

    var N2 = Math.ceil(N / M),
        N1 = N2 * Math.ceil(Math.sqrt(M)),
        i, j, right2, right3;

    multiSelect(items, left, right, N1, this.compareMinX);

    for (i = left; i &#x3c;= right; i += N1) {

        right2 = Math.min(i + N1 - 1, right);

        multiSelect(items, i, right2, N2, this.compareMinY);

        for (j = i; j &#x3c;= right2; j += N2) {

            right3 = Math.min(j + N2 - 1, right2);

            // pack each entry recursively
            node.children.push(this._build(items, j, right3, height - 1));
        }
    }

    calcBBox(node, this.toBBox);

    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    for (var i = 0, len = data.length; i &#x3c; len; i++) {
        this.insert(data[i]);
    }
    return this;
}

// recursively build the tree with the given data from stratch using OMT algorithm
var node = this.<span class="apidocCodeKeywordSpan">_build</span>(data.slice(), 0, data.length - 1, 0);

if (!this.data.children.length) {
    // save as is if tree is empty
    this.data = node;

} else if (this.data.height === node.height) {
    // split root if trees have the same height
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype._chooseSplitAxis" id="apidoc.element.rbush.rbush.prototype._chooseSplitAxis">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_chooseSplitAxis
        <span class="apidocSignatureSpan">(node, m, M)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_chooseSplitAxis = function (node, m, M) {

    var compareMinX = node.leaf ? this.compareMinX : compareNodeMinX,
        compareMinY = node.leaf ? this.compareMinY : compareNodeMinY,
        xMargin = this._allDistMargin(node, m, M, compareMinX),
        yMargin = this._allDistMargin(node, m, M, compareMinY);

    // if total distributions margin value is minimal for x, sort by minX,
    // otherwise it&#x27;s already sorted by minY
    if (xMargin &#x3c; yMargin) node.children.sort(compareMinX);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // split overflowed node into two
    _split: function (insertPath, level) {

var node = insertPath[level],
    M = node.children.length,
    m = this._minEntries;

this.<span class="apidocCodeKeywordSpan">_chooseSplitAxis</span>(node, m, M);

var splitIndex = this._chooseSplitIndex(node, m, M);

var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
newNode.height = node.height;
newNode.leaf = node.leaf;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype._chooseSplitIndex" id="apidoc.element.rbush.rbush.prototype._chooseSplitIndex">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_chooseSplitIndex
        <span class="apidocSignatureSpan">(node, m, M)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_chooseSplitIndex = function (node, m, M) {

    var i, bbox1, bbox2, overlap, area, minOverlap, minArea, index;

    minOverlap = minArea = Infinity;

    for (i = m; i &#x3c;= M - m; i++) {
        bbox1 = distBBox(node, 0, i, this.toBBox);
        bbox2 = distBBox(node, i, M, this.toBBox);

        overlap = intersectionArea(bbox1, bbox2);
        area = bboxArea(bbox1) + bboxArea(bbox2);

        // choose distribution with minimum overlap
        if (overlap &#x3c; minOverlap) {
            minOverlap = overlap;
            index = i;

            minArea = area &#x3c; minArea ? area : minArea;

        } else if (overlap === minOverlap) {
            // otherwise choose distribution with minimum area
            if (area &#x3c; minArea) {
                minArea = area;
                index = i;
            }
        }
    }

    return index;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

var node = insertPath[level],
    M = node.children.length,
    m = this._minEntries;

this._chooseSplitAxis(node, m, M);

var splitIndex = this.<span class="apidocCodeKeywordSpan">_chooseSplitIndex</span>(node, m, M);

var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
newNode.height = node.height;
newNode.leaf = node.leaf;

calcBBox(node, this.toBBox);
calcBBox(newNode, this.toBBox);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype._chooseSubtree" id="apidoc.element.rbush.rbush.prototype._chooseSubtree">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_chooseSubtree
        <span class="apidocSignatureSpan">(bbox, node, level, path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_chooseSubtree = function (bbox, node, level, path) {

    var i, len, child, targetNode, area, enlargement, minArea, minEnlargement;

    while (true) {
        path.push(node);

        if (node.leaf || path.length - 1 === level) break;

        minArea = minEnlargement = Infinity;

        for (i = 0, len = node.children.length; i &#x3c; len; i++) {
            child = node.children[i];
            area = bboxArea(child);
            enlargement = enlargedArea(bbox, child) - area;

            // choose entry with the least area enlargement
            if (enlargement &#x3c; minEnlargement) {
                minEnlargement = enlargement;
                minArea = area &#x3c; minArea ? area : minArea;
                targetNode = child;

            } else if (enlargement === minEnlargement) {
                // otherwise choose one with the smallest area
                if (area &#x3c; minArea) {
                    minArea = area;
                    targetNode = child;
                }
            }
        }

        node = targetNode || node.children[0];
    }

    return node;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    _insert: function (item, level, isNode) {

var toBBox = this.toBBox,
    bbox = isNode ? item : toBBox(item),
    insertPath = [];

// find the best node for accommodating the item, saving all nodes along the path too
var node = this.<span class="apidocCodeKeywordSpan">_chooseSubtree</span>(bbox, this.data, level, insertPath);

// put the item into the node
node.children.push(item);
extend(node, bbox);

// split on node overflow; propagate upwards if necessary
while (level &#x3e;= 0) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype._condense" id="apidoc.element.rbush.rbush.prototype._condense">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_condense
        <span class="apidocSignatureSpan">(path)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_condense = function (path) {
    // go through the path, removing empty nodes and updating bboxes
    for (var i = path.length - 1, siblings; i &#x3e;= 0; i--) {
        if (path[i].children.length === 0) {
            if (i &#x3e; 0) {
                siblings = path[i - 1].children;
                siblings.splice(siblings.indexOf(path[i]), 1);

            } else this.clear();

        } else calcBBox(path[i], this.toBBox);
    }
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
if (node.leaf) { // check current node
    index = findItem(item, node.children, equalsFn);

    if (index !== -1) {
        // item found, remove the item and condense tree upwards
        node.children.splice(index, 1);
        path.push(node);
        this.<span class="apidocCodeKeywordSpan">_condense</span>(path);
        return this;
    }
}

if (!goingUp &#x26;&#x26; !node.leaf &#x26;&#x26; contains(node, bbox)) { // go down
    path.push(node);
    indexes.push(i);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype._initFormat" id="apidoc.element.rbush.rbush.prototype._initFormat">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_initFormat
        <span class="apidocSignatureSpan">(format)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_initFormat = function (format) {
    // data format (minX, minY, maxX, maxY accessors)

    // uses eval-type function compilation instead of just accepting a toBBox function
    // because the algorithms are very sensitive to sorting functions performance,
    // so they should be dead simple and without inner calls

    var compareArr = [&#x27;return a&#x27;, &#x27; - b&#x27;, &#x27;;&#x27;];

    this.compareMinX = new Function(&#x27;a&#x27;, &#x27;b&#x27;, compareArr.join(format[0]));
    this.compareMinY = new Function(&#x27;a&#x27;, &#x27;b&#x27;, compareArr.join(format[1]));

    this.toBBox = new Function(&#x27;a&#x27;,
        &#x27;return {minX: a&#x27; + format[0] +
        &#x27;, minY: a&#x27; + format[1] +
        &#x27;, maxX: a&#x27; + format[2] +
        &#x27;, maxY: a&#x27; + format[3] + &#x27;};&#x27;);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    if (!(this instanceof rbush)) return new rbush(maxEntries, format);

    // max entries in a node is 9 by default; min node fill is 40% for best performance
    this._maxEntries = Math.max(4, maxEntries || 9);
    this._minEntries = Math.max(2, Math.ceil(this._maxEntries * 0.4));

    if (format) {
        this.<span class="apidocCodeKeywordSpan">_initFormat</span>(format);
    }

    this.clear();
}

rbush.prototype = {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype._insert" id="apidoc.element.rbush.rbush.prototype._insert">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_insert
        <span class="apidocSignatureSpan">(item, level, isNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_insert = function (item, level, isNode) {

    var toBBox = this.toBBox,
        bbox = isNode ? item : toBBox(item),
        insertPath = [];

    // find the best node for accommodating the item, saving all nodes along the path too
    var node = this._chooseSubtree(bbox, this.data, level, insertPath);

    // put the item into the node
    node.children.push(item);
    extend(node, bbox);

    // split on node overflow; propagate upwards if necessary
    while (level &#x3e;= 0) {
        if (insertPath[level].children.length &#x3e; this._maxEntries) {
            this._split(insertPath, level);
            level--;
        } else break;
    }

    // adjust bboxes along the insertion path
    this._adjustParentBBoxes(bbox, insertPath, level);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
            // swap trees if inserted one is bigger
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
        }

        // insert the small tree into the large tree at appropriate level
        this.<span class="apidocCodeKeywordSpan">_insert</span>(node, this.data.height - node.height - 1, true);
    }

    return this;
},

insert: function (item) {
    if (item) this._insert(item, this.data.height - 1);
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype._split" id="apidoc.element.rbush.rbush.prototype._split">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_split
        <span class="apidocSignatureSpan">(insertPath, level)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_split = function (insertPath, level) {

    var node = insertPath[level],
        M = node.children.length,
        m = this._minEntries;

    this._chooseSplitAxis(node, m, M);

    var splitIndex = this._chooseSplitIndex(node, m, M);

    var newNode = createNode(node.children.splice(splitIndex, node.children.length - splitIndex));
    newNode.height = node.height;
    newNode.leaf = node.leaf;

    calcBBox(node, this.toBBox);
    calcBBox(newNode, this.toBBox);

    if (level) insertPath[level - 1].children.push(newNode);
    else this._splitRoot(node, newNode);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
    // put the item into the node
    node.children.push(item);
    extend(node, bbox);

    // split on node overflow; propagate upwards if necessary
    while (level &#x3e;= 0) {
        if (insertPath[level].children.length &#x3e; this._maxEntries) {
            this.<span class="apidocCodeKeywordSpan">_split</span>(insertPath, level);
            level--;
        } else break;
    }

    // adjust bboxes along the insertion path
    this._adjustParentBBoxes(bbox, insertPath, level);
},
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype._splitRoot" id="apidoc.element.rbush.rbush.prototype._splitRoot">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>_splitRoot
        <span class="apidocSignatureSpan">(node, newNode)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">_splitRoot = function (node, newNode) {
    // split root node
    this.data = createNode([node, newNode]);
    this.data.height = node.height + 1;
    this.data.leaf = false;
    calcBBox(this.data, this.toBBox);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

if (!this.data.children.length) {
    // save as is if tree is empty
    this.data = node;

} else if (this.data.height === node.height) {
    // split root if trees have the same height
    this.<span class="apidocCodeKeywordSpan">_splitRoot</span>(this.data, node);

} else {
    if (this.data.height &#x3c; node.height) {
        // swap trees if inserted one is bigger
        var tmpNode = this.data;
        this.data = node;
        node = tmpNode;
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype.all" id="apidoc.element.rbush.rbush.prototype.all">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>all
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">all = function () {
    return this._all(this.data, []);
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...

Returns an array of data items (points or rectangles) that the given bounding box intersects.

Note that the `search` method accepts a bounding box in `{minX, minY, maxX, maxY}` format
regardless of the format specified in the constructor (which only affects inserted objects).

```js
var allItems = tree.<span class="apidocCodeKeywordSpan">all</span>();
```

Returns all items of the tree.

### Collisions

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype.clear" id="apidoc.element.rbush.rbush.prototype.clear">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>clear
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">clear = function () {
    this.data = createNode([]);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
tree.remove(itemCopy, function (a, b) {
    return a.id === b.id;
});

Remove all items:

```js
tree.<span class="apidocCodeKeywordSpan">clear</span>();
```

### Data Format

By default, RBush assumes the format of data points to be an object
with `minX`, `minY`, `maxX` and `maxY` properties.
You can customize this by providing an array with corresponding accessor strings
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype.collides" id="apidoc.element.rbush.rbush.prototype.collides">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>collides
        <span class="apidocSignatureSpan">(bbox)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">collides = function (bbox) {

    var node = this.data,
        toBBox = this.toBBox;

    if (!intersects(bbox, node)) return false;

    var nodesToSearch = [],
        i, len, child, childBBox;

    while (node) {
        for (i = 0, len = node.children.length; i &#x3c; len; i++) {

            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
                if (node.leaf || contains(bbox, childBBox)) return true;
                nodesToSearch.push(child);
            }
        }
        node = nodesToSearch.pop();
    }

    return false;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

Returns all items of the tree.

### Collisions

```js
var result = tree.<span class="apidocCodeKeywordSpan">collides</span>({minX: 40, minY: 20, maxX: 80, maxY: 70});
```

Returns `true` if there are any items intersecting the given bounding box, otherwise `false`.


### Export and Import
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype.compareMinX" id="apidoc.element.rbush.rbush.prototype.compareMinX">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>compareMinX
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareNodeMinX(a, b) { return a.minX - b.minX; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype.compareMinY" id="apidoc.element.rbush.rbush.prototype.compareMinY">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>compareMinY
        <span class="apidocSignatureSpan">(a, b)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">function compareNodeMinY(a, b) { return a.minY - b.minY; }</pre></li>
    <li>example usage<pre class="apidocCodePre">n/a</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype.fromJSON" id="apidoc.element.rbush.rbush.prototype.fromJSON">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>fromJSON
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">fromJSON = function (data) {
    this.data = data;
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
### Export and Import

```js
// export data as JSON object
var treeData = tree.toJSON();

// import previously exported data
var tree = rbush(9).<span class="apidocCodeKeywordSpan">fromJSON</span>(treeData);
```

Importing and exporting as JSON allows you to use RBush on both the server (using Node.js) and the browser combined,
e.g. first indexing the data on the server and and then importing the resulting tree data on the client for searching.

Note that the `nodeSize` option passed to the constructor must be the same in both trees for export/import to work properly.
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype.insert" id="apidoc.element.rbush.rbush.prototype.insert">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>insert
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">insert = function (item) {
    if (item) this._insert(item, this.data.height - 1);
    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
var item = {
    minX: 20,
    minY: 40,
    maxX: 30,
    maxY: 50,
    foo: &#x27;bar&#x27;
};
tree.<span class="apidocCodeKeywordSpan">insert</span>(item);
```

### Removing Data

Remove a previously inserted item:

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype.load" id="apidoc.element.rbush.rbush.prototype.load">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>load
        <span class="apidocSignatureSpan">(data)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">load = function (data) {
    if (!(data &#x26;&#x26; data.length)) return this;

    if (data.length &#x3c; this._minEntries) {
        for (var i = 0, len = data.length; i &#x3c; len; i++) {
            this.insert(data[i]);
        }
        return this;
    }

    // recursively build the tree with the given data from stratch using OMT algorithm
    var node = this._build(data.slice(), 0, data.length - 1, 0);

    if (!this.data.children.length) {
        // save as is if tree is empty
        this.data = node;

    } else if (this.data.height === node.height) {
        // split root if trees have the same height
        this._splitRoot(this.data, node);

    } else {
        if (this.data.height &#x3c; node.height) {
            // swap trees if inserted one is bigger
            var tmpNode = this.data;
            this.data = node;
            node = tmpNode;
        }

        // insert the small tree into the large tree at appropriate level
        this._insert(node, this.data.height - node.height - 1, true);
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### Bulk-Inserting Data

Bulk-insert the given data into the tree:

```js
tree.<span class="apidocCodeKeywordSpan">load</span>([item1, item2, ...]);
```

Bulk insertion is usually ~2-3 times faster than inserting items one by one.
After bulk loading (bulk insertion into an empty tree),
subsequent query performance is also ~20-30% better.

Note that when you do bulk insertion into an existing tree,
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype.remove" id="apidoc.element.rbush.rbush.prototype.remove">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>remove
        <span class="apidocSignatureSpan">(item, equalsFn)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">remove = function (item, equalsFn) {
    if (!item) return this;

    var node = this.data,
        bbox = this.toBBox(item),
        path = [],
        indexes = [],
        i, parent, index, goingUp;

    // depth-first iterative tree traversal
    while (node || path.length) {

        if (!node) { // go up
            node = path.pop();
            parent = path[path.length - 1];
            i = indexes.pop();
            goingUp = true;
        }

        if (node.leaf) { // check current node
            index = findItem(item, node.children, equalsFn);

            if (index !== -1) {
                // item found, remove the item and condense tree upwards
                node.children.splice(index, 1);
                path.push(node);
                this._condense(path);
                return this;
            }
        }

        if (!goingUp &#x26;&#x26; !node.leaf &#x26;&#x26; contains(node, bbox)) { // go down
            path.push(node);
            indexes.push(i);
            i = 0;
            parent = node;
            node = node.children[0];

        } else if (parent) { // go right
            i++;
            node = parent.children[i];
            goingUp = false;

        } else node = null; // nothing found
    }

    return this;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
```

### Removing Data

Remove a previously inserted item:

```js
tree.<span class="apidocCodeKeywordSpan">remove</span>(item);
```

By default, RBush removes objects by reference.
However, you can pass a custom `equals` function to compare by value for removal,
which is useful when you only have a copy of the object you need removed (e.g. loaded from server):

```js
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype.search" id="apidoc.element.rbush.rbush.prototype.search">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>search
        <span class="apidocSignatureSpan">(bbox)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">search = function (bbox) {

    var node = this.data,
        result = [],
        toBBox = this.toBBox;

    if (!intersects(bbox, node)) return result;

    var nodesToSearch = [],
        i, len, child, childBBox;

    while (node) {
        for (i = 0, len = node.children.length; i &#x3c; len; i++) {

            child = node.children[i];
            childBBox = node.leaf ? toBBox(child) : child;

            if (intersects(bbox, childBBox)) {
                if (node.leaf) result.push(child);
                else if (contains(bbox, childBBox)) this._all(child, result);
                else nodesToSearch.push(child);
            }
        }
        node = nodesToSearch.pop();
    }

    return result;
}</pre></li>
    <li>example usage<pre class="apidocCodePre">...
This means that bulk insertion works very well for clustered data
(where items in one update are close to each other),
but makes query performance worse if the data is scattered.

### Search

```js
var result = tree.<span class="apidocCodeKeywordSpan">search</span>({
    minX: 40,
    minY: 20,
    maxX: 80,
    maxY: 70
});
```
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype.toBBox" id="apidoc.element.rbush.rbush.prototype.toBBox">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>toBBox
        <span class="apidocSignatureSpan">(item)</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toBBox = function (item) { return item; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
return this;
    },

    remove: function (item, equalsFn) {
if (!item) return this;

var node = this.data,
    bbox = this.<span class="apidocCodeKeywordSpan">toBBox</span>(item),
    path = [],
    indexes = [],
    i, parent, index, goingUp;

// depth-first iterative tree traversal
while (node || path.length) {
...</pre></li>
    </ul>



    <h2>
        <a href="#apidoc.element.rbush.rbush.prototype.toJSON" id="apidoc.element.rbush.rbush.prototype.toJSON">
        function <span class="apidocSignatureSpan">rbush.rbush.prototype.</span>toJSON
        <span class="apidocSignatureSpan">()</span>
        </a>
    </h2>
    <ul>
    <li>description and source-code<pre class="apidocCodePre">toJSON = function () { return this.data; }</pre></li>
    <li>example usage<pre class="apidocCodePre">...
Returns `true` if there are any items intersecting the given bounding box, otherwise `false`.


### Export and Import

```js
// export data as JSON object
var treeData = tree.<span class="apidocCodeKeywordSpan">toJSON</span>();

// import previously exported data
var tree = rbush(9).fromJSON(treeData);
```

Importing and exporting as JSON allows you to use RBush on both the server (using Node.js) and the browser combined,
e.g. first indexing the data on the server and and then importing the resulting tree data on the client for searching.
...</pre></li>
    </ul>


</div>

<div class="apidocFooterDiv">
    [ this document was created with
    <a href="https://github.com/kaizhu256/node-utility2" target="_blank">utility2</a>
    ]
</div>
</div>
